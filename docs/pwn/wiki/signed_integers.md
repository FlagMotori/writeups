---
tags:
    - signed integers
    - two's complement
---





## مقدمه
همونطور که میدونیم عددها داخل کامپیوتر به صورت باینری ذخیره میشن. این موضوع مارو نیازمند به یک روش میکنه که بتونیم باهاش منفی بودن عدد رو نشون بدیم.  
سه روش کلی برای ذخیره اعداد علامت دار وجود داره که ۲ تاشون معمولا استفاده نمیشه. توی تمام این روش ها ۱ بودن بیت پر ارزش به معنی منفی بودن و ۰ بودن بیت پر ارزش به معنی مثبت بودن عدد هست.

### روش مقدار علامت
توی این روش وقتی عددی منفی هست فقط بیت علامتش (بیت پر ارزش) رو ۱ میزاریم. بدی این روش اینه که صفر ۲ تا نمایش داره. مثلا اگه عدد ۴ بیتی باشه هر دوی این ها صفر هستن.
```
0000
1000
```
دو نمایش برای عدد صفر بده، چون زمانی که پردازنده تساوی اعداد رو چک میکنه باید این حالت خاص رو در نظر بگیره.

بدی بعدی این روش اینه که وقتی پردازنده میخواد با اعداد عملیات ریاضی انجام بده باید به علامت عدد
دقت کنه و بسته به علامت این دو عدد به مدار های جمع کننده خاص نیاز داره. چرا؟ چون اگه بدون توجه به علامتشون این دو عدد جمع بشن، خروجی نهایی میشه `1100` که طبق منطق این روش میشه ۴-، که اشتباهه.  

```
 0011 (3)
+1001 (-1)
------
 ????
```


### روش مکمل ۱
توی این روش وقتی عدد منفی رو میخوایم ذخیره کنیم، از مثبت اون عدد مکمل ۱ میگیریم و عدد رو ذخیره میکنیم، که وقتی اینکارو انجام میدیم بیت پر ارزش ۱ میشه (بیت علامت).
این روش دوباره مشکل دو حالت نمایش برای عدد صفر رو داره، هر دوی این دو عدد صفر هستن.
```
0000
1111
```


با این روش پردازنده دیگه مدار مخصوص بسته به علامت عملوند ها نیاز نداره، ولی carry عدد باید با بیت کم ارزشش جمع شه.
```
   0011 (3)
  +1110 (-1)
   -----
1  0001
|--->+1
  ------
   0010 (2)
```
### روش مکمل ۲
این روش که توسط اکثر پردازنده ها استفاده میشه، شبیه روش مکمل ۱ هستش ولی به جای مکمل ۱، از عدد مکمل ۲ میگیریم.
توی این روش فقط یک نمایش برای عدد صفر رو داریم.
```
0000
```
با این روش پردازنده میتونه بدون توجه به علامت اعداد روشون عملیات ریاضی انجام بده.

```
    0011 (3)
   +1111 (-1)
   -----
1 | 0010 (2)
|
|---> overflowed
```


!!! نویسنده
    [Ali](https://github.com/AliGhaffarian)
